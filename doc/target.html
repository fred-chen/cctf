<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cctf.target API documentation</title>
<meta name="description" content="Created on Aug 25, 2018 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cctf.target</code></h1>
</header>
<section id="section-intro">
<p>Created on Aug 25, 2018</p>
<p>@author: fred</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Created on Aug 25, 2018

@author: fred
&#39;&#39;&#39;

import time

from .common import Common
from .me import is_server_svc_alive
from .shell import Shell
from .connection import Connection


def __execmd(conn, cmd, timeout=60):
    conn.write(&#39;ECHO=&#34;line_of_cctf2018&#34;&#39;)
    conn.nl()
    conn.write(&#34;echo start_$ECHO;&#34;)
    conn.nl()
    conn.waitfor(&#34;start_line_of_cctf2018&#34;, timeout)
    conn.write(cmd)
    conn.nl()
    conn.write(&#34;echo end_$ECHO&#34;)
    conn.nl()
    txt = conn.waitfor(&#34;end_line_of_cctf2018&#34;, timeout)
    return txt


class Target(Common):
    &#34;&#34;&#34;
        The target class. 

        A target object represents a remote host or any device that can be connected or logged in.
    &#34;&#34;&#34;

    def __init__(self, address, svc=&#39;ssh&#39;, username=&#39;root&#39;, password=None, conn=None, timeout=60):
        self.address = address
        self.svc = svc
        self.username = username
        self.password = password
        self.timeout = timeout
        self.hostname = None
        self.conn = conn
        self.shs = []
        self.shell = self.newshell(self.conn)
        self.shs.append(self.shell)
        self.exe = self.shell.exe   # target.exe() is just a delegation of target.shell.exe()
        self.__inittarget()

    def __inittarget(self):
        self.gethostname()

    def newshell(self, conn: Connection = None) -&gt; Shell:
        &#34;&#34;&#34;
            Create and return a new shell object associated with this target.

            newshell() returns a shell object. Users use shell object to operate on this target. A
            target object can have multiple shell objects associated on it. newshell() is actually a
            factory method of shell objects.

            Args:
                conn (Connection, optional): a connection object this shell reuses. Defaults to
                None. if conn is None, a new connection will be created.

            Returns:
                Shell: a shell object.
        &#34;&#34;&#34;
        shell = Shell(self, conn)
        if shell:
            self.shs.append(shell)
        return shell

    def __str__(self):
        if self.hostname:
            return f&#34;{self.address} - {self.hostname}&#34;
        else:
            return f&#34;{self.address}&#34;

    def gethostname(self) -&gt; str:
        &#34;&#34;&#34;Return the hostname of this target.&#34;&#34;&#34;

        raise NotImplementedError()

    def reboot(self, wait=True, log=True):
        &#34;&#34;&#34;Reboot the target. 

        Reboot the target gracefully, the target gets a chance to shutdown all services and then
        reboot.

        Args:
            wait (bool, optional): wait until the target is back online. Defaults to True. 
            log (bool, optional): log the reboot event. Defaults to True.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def panic(self, log=True):
        &#34;&#34;&#34; Panic the target.

        Panic the target immediately, the target hangs immediately without any chance to shutdown.
        Caution: The server will never come back online unless it is manually rebooted.

        Args:
            log (bool, optional): log the panic event. Defaults to True.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def panicreboot(self, wait=True, log=True):
        &#34;&#34;&#34; Panic the target and reboot it. 

        Panic the target immediately and reboot it. The target hangs immediately without any chance
        to shutdown, but it will reboot automatically. 

        Args:
            wait (bool, optional): wait until the target is back online. Defaults to True.
            log (bool, optional): log the panic event. Defaults to True.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def upload(self, local_path, remote_path, log=True) -&gt; bool:
        &#34;&#34;&#34; Upload a file to the target.

        Upload a file from local_path to remote_path on the target.

        Args:
            local_path (str): local file path, can be a file or a directory or a wildcard.
            remote_path (str): remote file path, can be a file or a directory.

        Returns:
            bool: True if success, False if failed.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def download(self, local_path, remote_path, log=True) -&gt; bool:
        &#34;&#34;&#34; Download a file from the target. 

        Download a file from remote_path on the target to local_path.

        Args:
            local_path (str): local file path, can be a file or a directory.
            remote_path (str): remote file path, can be a file or a directory or a wildcard.

        Returns:
            bool: True if success, False if failed. 
        &#34;&#34;&#34;
        raise NotImplementedError()

    def wait_alive(self, svc=None, timeout=None) -&gt; bool:
        &#34;&#34;&#34; Wait until the target is back online. 

        Wait until the target is back online. If svc is specified, wait until the service is back
        online. If timeout is specified, wait until the target is back online or timeout.

        Args:
            svc (str, optional): service name. Defaults to the service that was used to connect this
            target. 
            timeout (int, optional): timeout in seconds. Defaults to None, means wait forever.

        Returns:
            bool: True if the target is back online, False if timeout.
        &#34;&#34;&#34;
        self.log(
            f&#34;waiting on {self.address}:{str(svc) if svc else self.svc} to be online...&#34;)
        start = time.time()
        while not self.alive(svc, 1):
            dur = time.time() - start
            if timeout and dur &gt;= timeout:
                return False
        self.log(f&#34;{self.address}:{str(svc) if svc else self.svc} is back online.&#34;)
        return True

    def wait_down(self, svc=None, timeout=None) -&gt; bool:
        &#34;&#34;&#34; Wait until the target is down. 

        Wait until the target is down. If svc is specified, wait until the service is down. If
        timeout is specified, wait until the target is down or timeout.

        Args:
            svc (str, optional): service name. Defaults to the service that was used to connect this
            target.
            timeout (int, optional): timeout in seconds. Defaults to None, means wait forever.

        Returns:
            bool: True if the target is down, False if timeout.
        &#34;&#34;&#34;
        start = time.time()
        while self.alive(svc, 1):
            dur = time.time() - start
            if timeout and dur &gt;= timeout:
                return False
        self.log(f&#34;{self.address}:{str(svc) if svc else self.svc} is down.&#34;)
        return True

    def alive(self, svc=None, timeout=1) -&gt; bool:
        &#34;&#34;&#34; Check if the target is alive. 

        Check if the target is alive. If svc is specified, check if the service is alive. If timeout
        is specified, check if the target is alive or timeout.

        Args:
            svc (str, optional): service name. Defaults to the service that was used to connect this
            target.
            timeout (int, optional): timeout in seconds. Defaults to 1.

        Returns:
            bool: True if the target is alive, False if timeout.
        &#34;&#34;&#34;
        service = svc if svc else self.svc
        return is_server_svc_alive(host=self.address, svc=service, timeout=timeout)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cctf.target.Target"><code class="flex name class">
<span>class <span class="ident">Target</span></span>
<span>(</span><span>address, svc='ssh', username='root', password=None, conn=None, timeout=60)</span>
</code></dt>
<dd>
<div class="desc"><p>The target class. </p>
<p>A target object represents a remote host or any device that can be connected or logged in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Target(Common):
    &#34;&#34;&#34;
        The target class. 

        A target object represents a remote host or any device that can be connected or logged in.
    &#34;&#34;&#34;

    def __init__(self, address, svc=&#39;ssh&#39;, username=&#39;root&#39;, password=None, conn=None, timeout=60):
        self.address = address
        self.svc = svc
        self.username = username
        self.password = password
        self.timeout = timeout
        self.hostname = None
        self.conn = conn
        self.shs = []
        self.shell = self.newshell(self.conn)
        self.shs.append(self.shell)
        self.exe = self.shell.exe   # target.exe() is just a delegation of target.shell.exe()
        self.__inittarget()

    def __inittarget(self):
        self.gethostname()

    def newshell(self, conn: Connection = None) -&gt; Shell:
        &#34;&#34;&#34;
            Create and return a new shell object associated with this target.

            newshell() returns a shell object. Users use shell object to operate on this target. A
            target object can have multiple shell objects associated on it. newshell() is actually a
            factory method of shell objects.

            Args:
                conn (Connection, optional): a connection object this shell reuses. Defaults to
                None. if conn is None, a new connection will be created.

            Returns:
                Shell: a shell object.
        &#34;&#34;&#34;
        shell = Shell(self, conn)
        if shell:
            self.shs.append(shell)
        return shell

    def __str__(self):
        if self.hostname:
            return f&#34;{self.address} - {self.hostname}&#34;
        else:
            return f&#34;{self.address}&#34;

    def gethostname(self) -&gt; str:
        &#34;&#34;&#34;Return the hostname of this target.&#34;&#34;&#34;

        raise NotImplementedError()

    def reboot(self, wait=True, log=True):
        &#34;&#34;&#34;Reboot the target. 

        Reboot the target gracefully, the target gets a chance to shutdown all services and then
        reboot.

        Args:
            wait (bool, optional): wait until the target is back online. Defaults to True. 
            log (bool, optional): log the reboot event. Defaults to True.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def panic(self, log=True):
        &#34;&#34;&#34; Panic the target.

        Panic the target immediately, the target hangs immediately without any chance to shutdown.
        Caution: The server will never come back online unless it is manually rebooted.

        Args:
            log (bool, optional): log the panic event. Defaults to True.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def panicreboot(self, wait=True, log=True):
        &#34;&#34;&#34; Panic the target and reboot it. 

        Panic the target immediately and reboot it. The target hangs immediately without any chance
        to shutdown, but it will reboot automatically. 

        Args:
            wait (bool, optional): wait until the target is back online. Defaults to True.
            log (bool, optional): log the panic event. Defaults to True.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def upload(self, local_path, remote_path, log=True) -&gt; bool:
        &#34;&#34;&#34; Upload a file to the target.

        Upload a file from local_path to remote_path on the target.

        Args:
            local_path (str): local file path, can be a file or a directory or a wildcard.
            remote_path (str): remote file path, can be a file or a directory.

        Returns:
            bool: True if success, False if failed.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def download(self, local_path, remote_path, log=True) -&gt; bool:
        &#34;&#34;&#34; Download a file from the target. 

        Download a file from remote_path on the target to local_path.

        Args:
            local_path (str): local file path, can be a file or a directory.
            remote_path (str): remote file path, can be a file or a directory or a wildcard.

        Returns:
            bool: True if success, False if failed. 
        &#34;&#34;&#34;
        raise NotImplementedError()

    def wait_alive(self, svc=None, timeout=None) -&gt; bool:
        &#34;&#34;&#34; Wait until the target is back online. 

        Wait until the target is back online. If svc is specified, wait until the service is back
        online. If timeout is specified, wait until the target is back online or timeout.

        Args:
            svc (str, optional): service name. Defaults to the service that was used to connect this
            target. 
            timeout (int, optional): timeout in seconds. Defaults to None, means wait forever.

        Returns:
            bool: True if the target is back online, False if timeout.
        &#34;&#34;&#34;
        self.log(
            f&#34;waiting on {self.address}:{str(svc) if svc else self.svc} to be online...&#34;)
        start = time.time()
        while not self.alive(svc, 1):
            dur = time.time() - start
            if timeout and dur &gt;= timeout:
                return False
        self.log(f&#34;{self.address}:{str(svc) if svc else self.svc} is back online.&#34;)
        return True

    def wait_down(self, svc=None, timeout=None) -&gt; bool:
        &#34;&#34;&#34; Wait until the target is down. 

        Wait until the target is down. If svc is specified, wait until the service is down. If
        timeout is specified, wait until the target is down or timeout.

        Args:
            svc (str, optional): service name. Defaults to the service that was used to connect this
            target.
            timeout (int, optional): timeout in seconds. Defaults to None, means wait forever.

        Returns:
            bool: True if the target is down, False if timeout.
        &#34;&#34;&#34;
        start = time.time()
        while self.alive(svc, 1):
            dur = time.time() - start
            if timeout and dur &gt;= timeout:
                return False
        self.log(f&#34;{self.address}:{str(svc) if svc else self.svc} is down.&#34;)
        return True

    def alive(self, svc=None, timeout=1) -&gt; bool:
        &#34;&#34;&#34; Check if the target is alive. 

        Check if the target is alive. If svc is specified, check if the service is alive. If timeout
        is specified, check if the target is alive or timeout.

        Args:
            svc (str, optional): service name. Defaults to the service that was used to connect this
            target.
            timeout (int, optional): timeout in seconds. Defaults to 1.

        Returns:
            bool: True if the target is alive, False if timeout.
        &#34;&#34;&#34;
        service = svc if svc else self.svc
        return is_server_svc_alive(host=self.address, svc=service, timeout=timeout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cctf.common.Common" href="common.html#cctf.common.Common">Common</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cctf.uxtarget.UxTarget" href="uxtarget.html#cctf.uxtarget.UxTarget">UxTarget</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cctf.target.Target.alive"><code class="name flex">
<span>def <span class="ident">alive</span></span>(<span>self, svc=None, timeout=1) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the target is alive. </p>
<p>Check if the target is alive. If svc is specified, check if the service is alive. If timeout
is specified, check if the target is alive or timeout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>svc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name. Defaults to the service that was used to connect this</dd>
<dt>target.</dt>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>timeout in seconds. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the target is alive, False if timeout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alive(self, svc=None, timeout=1) -&gt; bool:
    &#34;&#34;&#34; Check if the target is alive. 

    Check if the target is alive. If svc is specified, check if the service is alive. If timeout
    is specified, check if the target is alive or timeout.

    Args:
        svc (str, optional): service name. Defaults to the service that was used to connect this
        target.
        timeout (int, optional): timeout in seconds. Defaults to 1.

    Returns:
        bool: True if the target is alive, False if timeout.
    &#34;&#34;&#34;
    service = svc if svc else self.svc
    return is_server_svc_alive(host=self.address, svc=service, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, local_path, remote_path, log=True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Download a file from the target. </p>
<p>Download a file from remote_path on the target to local_path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_path</code></strong> :&ensp;<code>str</code></dt>
<dd>local file path, can be a file or a directory.</dd>
<dt><strong><code>remote_path</code></strong> :&ensp;<code>str</code></dt>
<dd>remote file path, can be a file or a directory or a wildcard.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if success, False if failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, local_path, remote_path, log=True) -&gt; bool:
    &#34;&#34;&#34; Download a file from the target. 

    Download a file from remote_path on the target to local_path.

    Args:
        local_path (str): local file path, can be a file or a directory.
        remote_path (str): remote file path, can be a file or a directory or a wildcard.

    Returns:
        bool: True if success, False if failed. 
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.gethostname"><code class="name flex">
<span>def <span class="ident">gethostname</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the hostname of this target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gethostname(self) -&gt; str:
    &#34;&#34;&#34;Return the hostname of this target.&#34;&#34;&#34;

    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.newshell"><code class="name flex">
<span>def <span class="ident">newshell</span></span>(<span>self, conn: <a title="cctf.connection.Connection" href="connection.html#cctf.connection.Connection">Connection</a> = None) ‑> <a title="cctf.shell.Shell" href="shell.html#cctf.shell.Shell">Shell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new shell object associated with this target.</p>
<p>newshell() returns a shell object. Users use shell object to operate on this target. A
target object can have multiple shell objects associated on it. newshell() is actually a
factory method of shell objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conn</code></strong> :&ensp;<code>Connection</code>, optional</dt>
<dd>a connection object this shell reuses. Defaults to</dd>
</dl>
<p>None. if conn is None, a new connection will be created.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Shell</code></dt>
<dd>a shell object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newshell(self, conn: Connection = None) -&gt; Shell:
    &#34;&#34;&#34;
        Create and return a new shell object associated with this target.

        newshell() returns a shell object. Users use shell object to operate on this target. A
        target object can have multiple shell objects associated on it. newshell() is actually a
        factory method of shell objects.

        Args:
            conn (Connection, optional): a connection object this shell reuses. Defaults to
            None. if conn is None, a new connection will be created.

        Returns:
            Shell: a shell object.
    &#34;&#34;&#34;
    shell = Shell(self, conn)
    if shell:
        self.shs.append(shell)
    return shell</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.panic"><code class="name flex">
<span>def <span class="ident">panic</span></span>(<span>self, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Panic the target.</p>
<p>Panic the target immediately, the target hangs immediately without any chance to shutdown.
Caution: The server will never come back online unless it is manually rebooted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>log the panic event. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panic(self, log=True):
    &#34;&#34;&#34; Panic the target.

    Panic the target immediately, the target hangs immediately without any chance to shutdown.
    Caution: The server will never come back online unless it is manually rebooted.

    Args:
        log (bool, optional): log the panic event. Defaults to True.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.panicreboot"><code class="name flex">
<span>def <span class="ident">panicreboot</span></span>(<span>self, wait=True, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Panic the target and reboot it. </p>
<p>Panic the target immediately and reboot it. The target hangs immediately without any chance
to shutdown, but it will reboot automatically. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>wait until the target is back online. Defaults to True.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>log the panic event. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def panicreboot(self, wait=True, log=True):
    &#34;&#34;&#34; Panic the target and reboot it. 

    Panic the target immediately and reboot it. The target hangs immediately without any chance
    to shutdown, but it will reboot automatically. 

    Args:
        wait (bool, optional): wait until the target is back online. Defaults to True.
        log (bool, optional): log the panic event. Defaults to True.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.reboot"><code class="name flex">
<span>def <span class="ident">reboot</span></span>(<span>self, wait=True, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reboot the target. </p>
<p>Reboot the target gracefully, the target gets a chance to shutdown all services and then
reboot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>wait until the target is back online. Defaults to True. </dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>log the reboot event. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reboot(self, wait=True, log=True):
    &#34;&#34;&#34;Reboot the target. 

    Reboot the target gracefully, the target gets a chance to shutdown all services and then
    reboot.

    Args:
        wait (bool, optional): wait until the target is back online. Defaults to True. 
        log (bool, optional): log the reboot event. Defaults to True.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, local_path, remote_path, log=True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Upload a file to the target.</p>
<p>Upload a file from local_path to remote_path on the target.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_path</code></strong> :&ensp;<code>str</code></dt>
<dd>local file path, can be a file or a directory or a wildcard.</dd>
<dt><strong><code>remote_path</code></strong> :&ensp;<code>str</code></dt>
<dd>remote file path, can be a file or a directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if success, False if failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(self, local_path, remote_path, log=True) -&gt; bool:
    &#34;&#34;&#34; Upload a file to the target.

    Upload a file from local_path to remote_path on the target.

    Args:
        local_path (str): local file path, can be a file or a directory or a wildcard.
        remote_path (str): remote file path, can be a file or a directory.

    Returns:
        bool: True if success, False if failed.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.wait_alive"><code class="name flex">
<span>def <span class="ident">wait_alive</span></span>(<span>self, svc=None, timeout=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Wait until the target is back online. </p>
<p>Wait until the target is back online. If svc is specified, wait until the service is back
online. If timeout is specified, wait until the target is back online or timeout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>svc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name. Defaults to the service that was used to connect this</dd>
<dt>target.</dt>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>timeout in seconds. Defaults to None, means wait forever.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the target is back online, False if timeout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_alive(self, svc=None, timeout=None) -&gt; bool:
    &#34;&#34;&#34; Wait until the target is back online. 

    Wait until the target is back online. If svc is specified, wait until the service is back
    online. If timeout is specified, wait until the target is back online or timeout.

    Args:
        svc (str, optional): service name. Defaults to the service that was used to connect this
        target. 
        timeout (int, optional): timeout in seconds. Defaults to None, means wait forever.

    Returns:
        bool: True if the target is back online, False if timeout.
    &#34;&#34;&#34;
    self.log(
        f&#34;waiting on {self.address}:{str(svc) if svc else self.svc} to be online...&#34;)
    start = time.time()
    while not self.alive(svc, 1):
        dur = time.time() - start
        if timeout and dur &gt;= timeout:
            return False
    self.log(f&#34;{self.address}:{str(svc) if svc else self.svc} is back online.&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="cctf.target.Target.wait_down"><code class="name flex">
<span>def <span class="ident">wait_down</span></span>(<span>self, svc=None, timeout=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Wait until the target is down. </p>
<p>Wait until the target is down. If svc is specified, wait until the service is down. If
timeout is specified, wait until the target is down or timeout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>svc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name. Defaults to the service that was used to connect this</dd>
<dt>target.</dt>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>timeout in seconds. Defaults to None, means wait forever.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the target is down, False if timeout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_down(self, svc=None, timeout=None) -&gt; bool:
    &#34;&#34;&#34; Wait until the target is down. 

    Wait until the target is down. If svc is specified, wait until the service is down. If
    timeout is specified, wait until the target is down or timeout.

    Args:
        svc (str, optional): service name. Defaults to the service that was used to connect this
        target.
        timeout (int, optional): timeout in seconds. Defaults to None, means wait forever.

    Returns:
        bool: True if the target is down, False if timeout.
    &#34;&#34;&#34;
    start = time.time()
    while self.alive(svc, 1):
        dur = time.time() - start
        if timeout and dur &gt;= timeout:
            return False
    self.log(f&#34;{self.address}:{str(svc) if svc else self.svc} is down.&#34;)
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cctf" href="index.html">cctf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cctf.target.Target" href="#cctf.target.Target">Target</a></code></h4>
<ul class="two-column">
<li><code><a title="cctf.target.Target.alive" href="#cctf.target.Target.alive">alive</a></code></li>
<li><code><a title="cctf.target.Target.download" href="#cctf.target.Target.download">download</a></code></li>
<li><code><a title="cctf.target.Target.gethostname" href="#cctf.target.Target.gethostname">gethostname</a></code></li>
<li><code><a title="cctf.target.Target.newshell" href="#cctf.target.Target.newshell">newshell</a></code></li>
<li><code><a title="cctf.target.Target.panic" href="#cctf.target.Target.panic">panic</a></code></li>
<li><code><a title="cctf.target.Target.panicreboot" href="#cctf.target.Target.panicreboot">panicreboot</a></code></li>
<li><code><a title="cctf.target.Target.reboot" href="#cctf.target.Target.reboot">reboot</a></code></li>
<li><code><a title="cctf.target.Target.upload" href="#cctf.target.Target.upload">upload</a></code></li>
<li><code><a title="cctf.target.Target.wait_alive" href="#cctf.target.Target.wait_alive">wait_alive</a></code></li>
<li><code><a title="cctf.target.Target.wait_down" href="#cctf.target.Target.wait_down">wait_down</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>