<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cctf.shell API documentation</title>
<meta name="description" content="Created on Aug 25, 2018 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cctf.shell</code></h1>
</header>
<section id="section-intro">
<p>Created on Aug 25, 2018</p>
<p>@author: fred</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Created on Aug 25, 2018

@author: fred
&#39;&#39;&#39;

from queue import Queue
import threading
import random
import re, datetime, time, uuid
from . import common
from .common import Common
from .connfactory import connect
from .command import Command

class Shell(Common, threading.Thread):
    def __init__(self, target, conn=None, timeout=300):
        threading.Thread.__init__(self)
        self.q = Queue()
        self.t = target
        self.conn = conn
        self.timeout = timeout
        self.id = str(uuid.uuid4()).split(&#39;-&#39;)[0]
        self.connect()
        self.setDaemon(True)
        self.start()
        
    def connect(self):
        if (self.conn is None):
            self.conn = connect(self.t.address, self.t.username, self.t.password, self.t.svc, self.t.timeout, self.t.newline)
        if self.conn: self.setshell()
        return self.conn
    def setshell(self):
        self.conn.write(&#34;set +H&#34;)
        self.conn.nl()
        self.conn.write(&#34;trap ctrl_c INT &amp;&amp; function ctrl_c() { echo \&#34;Trapped CTRL-C\&#34;; }&#34;)
        self.conn.nl()
    def reconnect(self):
        self.disconnect()
        return self.connect()
    def disconnect(self):
        if self.conn:
            self.conn.disconnect()
        self.conn = None
    
    def exe(self, cmdline, wait=True, log=True, longrun_report=1800, wait_report=30) -&gt; Command:
        &#34;&#34;&#34;put a command into q, wait to be executed by the shelll thread

        Args:
            cmdline (str): the command line to be run in shell
            wait (bool, optional): if not wait, return immediately, else wait until the command is finished. Defaults to True.
            log (bool, optional): print result when finish. Defaults to True.
            longrun_report (int, optional): time to report progress if no one is watching, but a command is talking every long. Defaults to 1800.
            wait_report (int, optional): time to report progress when someone is watching (calling command.wait()). Defaults to 30.

        Returns:
            Command object: the command object
        &#34;&#34;&#34;
        cmdobj                = Command(cmdline, log, longrun_report, wait_report)
        cmdobj.shell          = self
        self.q.put(cmdobj)
        if wait:
            cmdobj.wait()
        return cmdobj
    
    def getconn(self):
        return self.conn

    def gettarget(self):
        return self.t
    
    def run(self):
        while True:
            cmdobj = self.q.get()
            filename = &#34;CCTF_%s_%s&#34; % (threading.current_thread().ident, random.randrange(1000000000))
            cmdobj.reserve = filename
            start = datetime.datetime.now()
            for i in range(1, 6):
                broken = False
                if self._sendcmd(cmdobj) is None:
                    broken = True
                start = datetime.datetime.now()
                cmdobj.start = start
                if self._getresults(cmdobj) is None:  # connection broken
                    broken = True
                if broken:
                    dur = 0; alive = False
                    timeout = self.timeout if self.timeout else 900 # default timeout is 15 minutes
                    self.log(&#34;connection broken. resending command &#39;%s&#39;. timeout %d secs, attempt %d ...&#34; % (cmdobj.cmdline, timeout, i), 2)
                    while True:
                        if self.t.alive():
                            alive = True
                            break
                        else:
                            time.sleep(1)
                            dur += 1
                            if dur &gt; timeout: break
                    if alive: self.reconnect()
                    continue
                else:
                    break
            diff = datetime.datetime.now() - start
            cmdobj.dur = diff.total_seconds() * 1000
            cmdobj.setdone()
    
    def _sendcmd(self, cmdobj: Command):
        cmdline = cmdobj.cmdline.replace(&#39;&#34;&#39;, r&#39;\&#34;&#39;)
        cmd  = f&#34;FN=/tmp/{cmdobj.reserve};&#34;
        # we use &#39;tee&#39; because we also want to capture the terminal screen of the command, so we can monitor the long running commands
        cmd += &#39;eval &#34;%s&#34; &gt; &gt;(tee ${FN}.out) 2&gt; &gt;(tee ${FN}.err &gt;&amp;2); echo $?&gt;${FN}.exit; stdbuf -o0 echo -ne &#34; &#34;;&#39; % (cmdline)
        # cmd += f&#39;eval &#34;{cmdline}&#34; &gt; $FN.out 2&gt;$FN.err; echo $?&gt;$FN.exit; stdbuf -o0 echo -ne &#34; &#34;;&#39;
        cmd += &#34;while [ ! -e ${FN}.out ]; do continue; done; sync ${FN}.out;&#34; # wait for output files to be generated
        cmd += &#34;echo ==${FN}START==;&#34;
        cmd += &#34;cat ${FN}.out;echo ==OUTEND==;&#34;
        cmd += &#34;cat ${FN}.err;echo ==ERREND==;&#34;
        cmd += &#34;cat ${FN}.exit;echo ==EXITEND==;&#34;
        cmd += &#34;echo ==${FN}END==;&#34;
        cmd += &#34;rm -f ${FN}.out ${FN}.err ${FN}.exit&#34;
        if (not self.conn) or self.conn.write(cmd) is None:
            return None
        return self.conn.nl()
    
    def _getresults(self, cmdobj):
        txt = None
        regScreen = re.compile(&#34;==/tmp/%sSTART==(.+)==OUTEND==(.+)==ERREND==(.+)==EXITEND==.+==/tmp/%sEND==&#34; % (cmdobj.reserve, cmdobj.reserve), re.DOTALL)
        cmdobj.screentext = &#34;&#34;
        if self.conn:
            while True:
                txt = self.conn.waitfor(&#34;==/tmp/%sEND==&#34; % (cmdobj.reserve), 1)
                if txt is None:   # connection broken
                    cmdobj.stdout     = None
                    cmdobj.stderr     = None
                    cmdobj.exit       = None
                    return txt
                cmdobj.screentext += txt.replace(self.UNIQIDENTIFIER, &#34;&#34;)
                m = regScreen.search(cmdobj.screentext)
                if m:   # command finished
                    break
                dur = datetime.datetime.now() - cmdobj.start
                if int(dur.total_seconds()) == 1:  # report command running for one time
                    self.log(&#34;running &#39;%s&#39;&#34; % (cmdobj.cmdline))
                if cmdobj.longrun_report:
                    if dur.total_seconds() &gt;= cmdobj.longrun_report and int(dur.total_seconds()) % cmdobj.longrun_report == 0:
                        self.log(&#34;command has been running for %d seconds. %s\n\n&#34; % (dur.total_seconds(), cmdobj))
        else:   # connection broken
            cmdobj.stdout = None
            cmdobj.stderr = None
            cmdobj.exit = None
            return txt
        m = regScreen.search(cmdobj.screentext)
        cmdobj.stdout     = m.group(1)
        cmdobj.stderr     = m.group(2)
        cmdobj.exit       = m.group(3)
        # print(&#34;screen:\n%s&#34; % cmdobj.screentext)  # for debug
        return txt
    
    def interrupt(self, send=&#39;\x03&#39;):
        &#34;&#34;&#34;terminate the current command with &#39;ctrl-c&#39; (&#39;\x03&#39;)

        Args:
            send (str, optional): the control character to terminate the current forground process. Defaults to &#39;\x03&#39;.
        &#34;&#34;&#34;
        self.conn.write(send)

    def log(self, msg, level=3):
        Common.log(&#34;[%s(%s)]: %s&#34; % (self.t, self.id, msg), level)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cctf.shell.Shell"><code class="flex name class">
<span>class <span class="ident">Shell</span></span>
<span>(</span><span>target, conn=None, timeout=300)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shell(Common, threading.Thread):
    def __init__(self, target, conn=None, timeout=300):
        threading.Thread.__init__(self)
        self.q = Queue()
        self.t = target
        self.conn = conn
        self.timeout = timeout
        self.id = str(uuid.uuid4()).split(&#39;-&#39;)[0]
        self.connect()
        self.setDaemon(True)
        self.start()
        
    def connect(self):
        if (self.conn is None):
            self.conn = connect(self.t.address, self.t.username, self.t.password, self.t.svc, self.t.timeout, self.t.newline)
        if self.conn: self.setshell()
        return self.conn
    def setshell(self):
        self.conn.write(&#34;set +H&#34;)
        self.conn.nl()
        self.conn.write(&#34;trap ctrl_c INT &amp;&amp; function ctrl_c() { echo \&#34;Trapped CTRL-C\&#34;; }&#34;)
        self.conn.nl()
    def reconnect(self):
        self.disconnect()
        return self.connect()
    def disconnect(self):
        if self.conn:
            self.conn.disconnect()
        self.conn = None
    
    def exe(self, cmdline, wait=True, log=True, longrun_report=1800, wait_report=30) -&gt; Command:
        &#34;&#34;&#34;put a command into q, wait to be executed by the shelll thread

        Args:
            cmdline (str): the command line to be run in shell
            wait (bool, optional): if not wait, return immediately, else wait until the command is finished. Defaults to True.
            log (bool, optional): print result when finish. Defaults to True.
            longrun_report (int, optional): time to report progress if no one is watching, but a command is talking every long. Defaults to 1800.
            wait_report (int, optional): time to report progress when someone is watching (calling command.wait()). Defaults to 30.

        Returns:
            Command object: the command object
        &#34;&#34;&#34;
        cmdobj                = Command(cmdline, log, longrun_report, wait_report)
        cmdobj.shell          = self
        self.q.put(cmdobj)
        if wait:
            cmdobj.wait()
        return cmdobj
    
    def getconn(self):
        return self.conn

    def gettarget(self):
        return self.t
    
    def run(self):
        while True:
            cmdobj = self.q.get()
            filename = &#34;CCTF_%s_%s&#34; % (threading.current_thread().ident, random.randrange(1000000000))
            cmdobj.reserve = filename
            start = datetime.datetime.now()
            for i in range(1, 6):
                broken = False
                if self._sendcmd(cmdobj) is None:
                    broken = True
                start = datetime.datetime.now()
                cmdobj.start = start
                if self._getresults(cmdobj) is None:  # connection broken
                    broken = True
                if broken:
                    dur = 0; alive = False
                    timeout = self.timeout if self.timeout else 900 # default timeout is 15 minutes
                    self.log(&#34;connection broken. resending command &#39;%s&#39;. timeout %d secs, attempt %d ...&#34; % (cmdobj.cmdline, timeout, i), 2)
                    while True:
                        if self.t.alive():
                            alive = True
                            break
                        else:
                            time.sleep(1)
                            dur += 1
                            if dur &gt; timeout: break
                    if alive: self.reconnect()
                    continue
                else:
                    break
            diff = datetime.datetime.now() - start
            cmdobj.dur = diff.total_seconds() * 1000
            cmdobj.setdone()
    
    def _sendcmd(self, cmdobj: Command):
        cmdline = cmdobj.cmdline.replace(&#39;&#34;&#39;, r&#39;\&#34;&#39;)
        cmd  = f&#34;FN=/tmp/{cmdobj.reserve};&#34;
        # we use &#39;tee&#39; because we also want to capture the terminal screen of the command, so we can monitor the long running commands
        cmd += &#39;eval &#34;%s&#34; &gt; &gt;(tee ${FN}.out) 2&gt; &gt;(tee ${FN}.err &gt;&amp;2); echo $?&gt;${FN}.exit; stdbuf -o0 echo -ne &#34; &#34;;&#39; % (cmdline)
        # cmd += f&#39;eval &#34;{cmdline}&#34; &gt; $FN.out 2&gt;$FN.err; echo $?&gt;$FN.exit; stdbuf -o0 echo -ne &#34; &#34;;&#39;
        cmd += &#34;while [ ! -e ${FN}.out ]; do continue; done; sync ${FN}.out;&#34; # wait for output files to be generated
        cmd += &#34;echo ==${FN}START==;&#34;
        cmd += &#34;cat ${FN}.out;echo ==OUTEND==;&#34;
        cmd += &#34;cat ${FN}.err;echo ==ERREND==;&#34;
        cmd += &#34;cat ${FN}.exit;echo ==EXITEND==;&#34;
        cmd += &#34;echo ==${FN}END==;&#34;
        cmd += &#34;rm -f ${FN}.out ${FN}.err ${FN}.exit&#34;
        if (not self.conn) or self.conn.write(cmd) is None:
            return None
        return self.conn.nl()
    
    def _getresults(self, cmdobj):
        txt = None
        regScreen = re.compile(&#34;==/tmp/%sSTART==(.+)==OUTEND==(.+)==ERREND==(.+)==EXITEND==.+==/tmp/%sEND==&#34; % (cmdobj.reserve, cmdobj.reserve), re.DOTALL)
        cmdobj.screentext = &#34;&#34;
        if self.conn:
            while True:
                txt = self.conn.waitfor(&#34;==/tmp/%sEND==&#34; % (cmdobj.reserve), 1)
                if txt is None:   # connection broken
                    cmdobj.stdout     = None
                    cmdobj.stderr     = None
                    cmdobj.exit       = None
                    return txt
                cmdobj.screentext += txt.replace(self.UNIQIDENTIFIER, &#34;&#34;)
                m = regScreen.search(cmdobj.screentext)
                if m:   # command finished
                    break
                dur = datetime.datetime.now() - cmdobj.start
                if int(dur.total_seconds()) == 1:  # report command running for one time
                    self.log(&#34;running &#39;%s&#39;&#34; % (cmdobj.cmdline))
                if cmdobj.longrun_report:
                    if dur.total_seconds() &gt;= cmdobj.longrun_report and int(dur.total_seconds()) % cmdobj.longrun_report == 0:
                        self.log(&#34;command has been running for %d seconds. %s\n\n&#34; % (dur.total_seconds(), cmdobj))
        else:   # connection broken
            cmdobj.stdout = None
            cmdobj.stderr = None
            cmdobj.exit = None
            return txt
        m = regScreen.search(cmdobj.screentext)
        cmdobj.stdout     = m.group(1)
        cmdobj.stderr     = m.group(2)
        cmdobj.exit       = m.group(3)
        # print(&#34;screen:\n%s&#34; % cmdobj.screentext)  # for debug
        return txt
    
    def interrupt(self, send=&#39;\x03&#39;):
        &#34;&#34;&#34;terminate the current command with &#39;ctrl-c&#39; (&#39;\x03&#39;)

        Args:
            send (str, optional): the control character to terminate the current forground process. Defaults to &#39;\x03&#39;.
        &#34;&#34;&#34;
        self.conn.write(send)

    def log(self, msg, level=3):
        Common.log(&#34;[%s(%s)]: %s&#34; % (self.t, self.id, msg), level)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cctf.common.Common" href="common.html#cctf.common.Common">Common</a></li>
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cctf.shell.Shell.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    if (self.conn is None):
        self.conn = connect(self.t.address, self.t.username, self.t.password, self.t.svc, self.t.timeout, self.t.newline)
    if self.conn: self.setshell()
    return self.conn</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    if self.conn:
        self.conn.disconnect()
    self.conn = None</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.exe"><code class="name flex">
<span>def <span class="ident">exe</span></span>(<span>self, cmdline, wait=True, log=True, longrun_report=1800, wait_report=30) â€‘>Â <a title="cctf.command.Command" href="command.html#cctf.command.Command">Command</a></span>
</code></dt>
<dd>
<div class="desc"><p>put a command into q, wait to be executed by the shelll thread</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmdline</code></strong> :&ensp;<code>str</code></dt>
<dd>the command line to be run in shell</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if not wait, return immediately, else wait until the command is finished. Defaults to True.</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>print result when finish. Defaults to True.</dd>
<dt><strong><code>longrun_report</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>time to report progress if no one is watching, but a command is talking every long. Defaults to 1800.</dd>
<dt><strong><code>wait_report</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>time to report progress when someone is watching (calling command.wait()). Defaults to 30.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Command object</code></dt>
<dd>the command object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exe(self, cmdline, wait=True, log=True, longrun_report=1800, wait_report=30) -&gt; Command:
    &#34;&#34;&#34;put a command into q, wait to be executed by the shelll thread

    Args:
        cmdline (str): the command line to be run in shell
        wait (bool, optional): if not wait, return immediately, else wait until the command is finished. Defaults to True.
        log (bool, optional): print result when finish. Defaults to True.
        longrun_report (int, optional): time to report progress if no one is watching, but a command is talking every long. Defaults to 1800.
        wait_report (int, optional): time to report progress when someone is watching (calling command.wait()). Defaults to 30.

    Returns:
        Command object: the command object
    &#34;&#34;&#34;
    cmdobj                = Command(cmdline, log, longrun_report, wait_report)
    cmdobj.shell          = self
    self.q.put(cmdobj)
    if wait:
        cmdobj.wait()
    return cmdobj</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.getconn"><code class="name flex">
<span>def <span class="ident">getconn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getconn(self):
    return self.conn</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.gettarget"><code class="name flex">
<span>def <span class="ident">gettarget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gettarget(self):
    return self.t</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span>(<span>self, send='\x03')</span>
</code></dt>
<dd>
<div class="desc"><p>terminate the current command with 'ctrl-c' ('')</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>send</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the control character to terminate the current forground process. Defaults to ''.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interrupt(self, send=&#39;\x03&#39;):
    &#34;&#34;&#34;terminate the current command with &#39;ctrl-c&#39; (&#39;\x03&#39;)

    Args:
        send (str, optional): the control character to terminate the current forground process. Defaults to &#39;\x03&#39;.
    &#34;&#34;&#34;
    self.conn.write(send)</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg, level=3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, msg, level=3):
    Common.log(&#34;[%s(%s)]: %s&#34; % (self.t, self.id, msg), level)</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    self.disconnect()
    return self.connect()</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    while True:
        cmdobj = self.q.get()
        filename = &#34;CCTF_%s_%s&#34; % (threading.current_thread().ident, random.randrange(1000000000))
        cmdobj.reserve = filename
        start = datetime.datetime.now()
        for i in range(1, 6):
            broken = False
            if self._sendcmd(cmdobj) is None:
                broken = True
            start = datetime.datetime.now()
            cmdobj.start = start
            if self._getresults(cmdobj) is None:  # connection broken
                broken = True
            if broken:
                dur = 0; alive = False
                timeout = self.timeout if self.timeout else 900 # default timeout is 15 minutes
                self.log(&#34;connection broken. resending command &#39;%s&#39;. timeout %d secs, attempt %d ...&#34; % (cmdobj.cmdline, timeout, i), 2)
                while True:
                    if self.t.alive():
                        alive = True
                        break
                    else:
                        time.sleep(1)
                        dur += 1
                        if dur &gt; timeout: break
                if alive: self.reconnect()
                continue
            else:
                break
        diff = datetime.datetime.now() - start
        cmdobj.dur = diff.total_seconds() * 1000
        cmdobj.setdone()</code></pre>
</details>
</dd>
<dt id="cctf.shell.Shell.setshell"><code class="name flex">
<span>def <span class="ident">setshell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setshell(self):
    self.conn.write(&#34;set +H&#34;)
    self.conn.nl()
    self.conn.write(&#34;trap ctrl_c INT &amp;&amp; function ctrl_c() { echo \&#34;Trapped CTRL-C\&#34;; }&#34;)
    self.conn.nl()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cctf" href="index.html">cctf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cctf.shell.Shell" href="#cctf.shell.Shell">Shell</a></code></h4>
<ul class="two-column">
<li><code><a title="cctf.shell.Shell.connect" href="#cctf.shell.Shell.connect">connect</a></code></li>
<li><code><a title="cctf.shell.Shell.disconnect" href="#cctf.shell.Shell.disconnect">disconnect</a></code></li>
<li><code><a title="cctf.shell.Shell.exe" href="#cctf.shell.Shell.exe">exe</a></code></li>
<li><code><a title="cctf.shell.Shell.getconn" href="#cctf.shell.Shell.getconn">getconn</a></code></li>
<li><code><a title="cctf.shell.Shell.gettarget" href="#cctf.shell.Shell.gettarget">gettarget</a></code></li>
<li><code><a title="cctf.shell.Shell.interrupt" href="#cctf.shell.Shell.interrupt">interrupt</a></code></li>
<li><code><a title="cctf.shell.Shell.log" href="#cctf.shell.Shell.log">log</a></code></li>
<li><code><a title="cctf.shell.Shell.reconnect" href="#cctf.shell.Shell.reconnect">reconnect</a></code></li>
<li><code><a title="cctf.shell.Shell.run" href="#cctf.shell.Shell.run">run</a></code></li>
<li><code><a title="cctf.shell.Shell.setshell" href="#cctf.shell.Shell.setshell">setshell</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>